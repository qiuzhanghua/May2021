# May2021

## 问题描述
一般地：
设f(x)是一个正整数到正整数的函数(如RSA加密)，g(x)是f(x)的反函数(如RSA解密)，那么

g(f(x)*f(y)) = x * y

这就是乘法同态。

实现一个简单的基于RSA的同态加密算法，完成RSA.java中各种方法的实现，以保证单元测试通过，程序正常运行。

单元测试
```bash
gradle test
```

程序运行
```bash
gradle run

# 结果如下：
# 10324234 * 546576 = 5642978522784
```

## 附：RSA算法

### 密钥生成

1 随机找两个质数P和Q，越大越安全，并计算乘积𝑛=𝑃∗𝑄。P和Q的乘积的二进制位数代表RSA加密的位数，一般来说都要有1024或2048位。

2 计算n的欧拉函数𝜙(𝑛)，表示在小于等于n的正整数中，与n构成互质关系的数的个数。比如1~8中，和8互质的有 1,3,5,7，所以 𝜙(8)=4，如果p和q为质数，那么他们的乘积的欧拉函数有一个特殊的性质，公式为𝜙(𝑛)=𝜙(𝑃∗𝑄)=𝜙(𝑃−1)𝜙(𝑄−1)=(𝑃−1)(𝑄−1)

3 选取e，要大于1小于𝜙(𝑛)，并且e与 𝜙(𝑛) 要互质

4 计算出一个整数d，使得 (𝑒𝑑−1) % 𝜙(𝑛)=0，即𝑒∗𝑑除以𝜙(𝑛)的余数为1，实际上转化为找到二元一次方程 𝑒𝑑+𝑘𝜙(𝑛)=1的一组解（求d和k），具体使用的是扩展欧几里得算法
于是我们可以得到：

公钥 (n, e)

私钥 (n, d)

在这样的条件下，如果想要根据 n 和 e 算出 d，就只能暴力破解，位数越长，玻璃破解时间越长。

### 加密
我们现在有个这么几个关键的数值：n, e, d。要使用公钥(n, e)加密，首先要求被加密的数字必须是整数且小于 n（如果是字符串，可以逐个取ascii码或unicode值，并且中间用非数字和字母分割即可）。假设我们需要加密的数字是A，则加密之后的B为（为了区别使用大写）：

𝐴的e次方 % 𝑛=𝐵

如果没有 d，那么是很难从B中恢复A的。

### 解密
如果我们拥有私钥 (n, d)，那么对于 B，就可以通过下面的公式计算出 A：

𝐵的𝑑次方 % 𝑛=𝐴